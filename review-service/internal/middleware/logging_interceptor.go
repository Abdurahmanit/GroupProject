package middleware

import (
	"context"
	"errors"
	"strings"

	"github.com/Abdurahmanit/GroupProject/review-service/internal/platform/logger" // Adjust path if necessary
	"github.com/golang-jwt/jwt/v5"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
)

// UserIDKeyType is a custom type for the user ID context key to avoid collisions.
type UserIDKeyType string

// UserRoleKeyType is a custom type for the user role context key.
type UserRoleKeyType string

const (
	// UserIDKey is the key used to store and retrieve the authenticated UserID from the context.
	UserIDKey UserIDKeyType = "authenticatedUserID"
	// UserRoleKey is the key used to store and retrieve the authenticated user's role from the context.
	UserRoleKey UserRoleKeyType = "authenticatedUserRole"
)

// Claims defines the structure of the JWT claims expected from the token.
// This should match the claims structure generated by your user-service or API Gateway.
type Claims struct {
	UserID string `json:"user_id"`
	Role   string `json:"role"` // e.g., "customer", "admin"
	// Add other claims like "email", "username" if needed by the service,
	// but UserID and Role are primary for authorization.
	jwt.RegisteredClaims
}

// AuthInterceptor creates a gRPC unary server interceptor for authentication and basic authorization.
// jwtSecret is the secret key used to validate JWTs.
// publicMethods is a map where keys are full gRPC method paths (e.g., "/review.ReviewService/GetReview")
// and values are true if the method is public (does not require authentication).
// requiredRoles is a map where keys are full gRPC method paths and values are slices of roles
// allowed to access that method (e.g., {"/review.ReviewService/ModerateReview": ["admin"]}).
// If a method is not in requiredRoles, it's assumed to be accessible by any authenticated user (after passing publicMethods check).
func AuthInterceptor(jwtSecret string, log *logger.Logger, publicMethods map[string]bool, requiredRoles map[string][]string) grpc.UnaryServerInterceptor {
	return func(
		ctx context.Context,
		req interface{},
		info *grpc.UnaryServerInfo,
		handler grpc.UnaryHandler,
	) (interface{}, error) {
		log.Debug("AuthInterceptor: processing request", zap.String("method", info.FullMethod))

		// 1. Check if the method is public
		if publicMethods[info.FullMethod] {
			log.Debug("AuthInterceptor: public method, skipping authentication", zap.String("method", info.FullMethod))
			return handler(ctx, req)
		}
		log.Debug("AuthInterceptor: protected method, proceeding with authentication", zap.String("method", info.FullMethod))

		// 2. Extract token from metadata
		md, ok := metadata.FromIncomingContext(ctx)
		if !ok {
			log.Warn("AuthInterceptor: missing metadata from context", zap.String("method", info.FullMethod))
			return nil, status.Errorf(codes.Unauthenticated, "metadata is not provided")
		}

		authHeaders := md.Get("authorization") // gRPC metadata keys are typically lowercase
		if len(authHeaders) == 0 {
			log.Warn("AuthInterceptor: 'authorization' header not found in metadata", zap.String("method", info.FullMethod))
			return nil, status.Errorf(codes.Unauthenticated, "authorization token is not provided")
		}

		authHeader := authHeaders[0]
		parts := strings.Fields(authHeader)
		if len(parts) != 2 || !strings.EqualFold(parts[0], "Bearer") {
			log.Warn("AuthInterceptor: invalid 'authorization' header format", zap.String("method", info.FullMethod), zap.String("header_value", authHeader))
			return nil, status.Errorf(codes.Unauthenticated, "authorization token format is invalid, expected 'Bearer <token>'")
		}
		tokenString := parts[1]

		if tokenString == "" {
			log.Warn("AuthInterceptor: token string is empty", zap.String("method", info.FullMethod))
			return nil, status.Errorf(codes.Unauthenticated, "authorization token is empty")
		}

		// 3. Parse and validate JWT
		claims := &Claims{}
		token, err := jwt.ParseWithClaims(tokenString, claims, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				log.Error("AuthInterceptor: unexpected signing method", zap.String("method", info.FullMethod), zap.Any("algorithm", token.Header["alg"]))
				return nil, status.Errorf(codes.Unauthenticated, "unexpected signing method: %v", token.Header["alg"])
			}
			return []byte(jwtSecret), nil
		})

		if err != nil {
			log.Warn("AuthInterceptor: token parsing or validation failed", zap.String("method", info.FullMethod), zap.Error(err))
			if errors.Is(err, jwt.ErrTokenExpired) {
				return nil, status.Errorf(codes.Unauthenticated, "token has expired")
			}
			return nil, status.Errorf(codes.Unauthenticated, "token is invalid: %v", err)
		}

		if !token.Valid {
			log.Warn("AuthInterceptor: token is not valid (claims validation failed or signature mismatch)", zap.String("method", info.FullMethod))
			return nil, status.Errorf(codes.Unauthenticated, "token is not valid")
		}

		// 4. Check for essential claims
		if claims.UserID == "" {
			log.Error("AuthInterceptor: UserID not found in token claims", zap.String("method", info.FullMethod))
			return nil, status.Errorf(codes.Unauthenticated, "UserID not found in token claims")
		}
		if claims.Role == "" { // Role is important for authorization
			log.Warn("AuthInterceptor: Role not found in token claims", zap.String("method", info.FullMethod), zap.String("user_id", claims.UserID))
			// Depending on policy, this could be an error or a default role assigned.
			// For now, let's treat it as potentially problematic for role-based access.
			// If all authenticated users can access non-admin routes, this might be okay.
			// However, for clarity, it's better if roles are always present.
			// For now, we'll proceed but log a warning.
		}

		// 5. Role-based authorization
		if roles, methodRequiresRoles := requiredRoles[info.FullMethod]; methodRequiresRoles {
			authorized := false
			for _, requiredRole := range roles {
				if claims.Role == requiredRole {
					authorized = true
					break
				}
			}
			if !authorized {
				log.Warn("AuthInterceptor: user does not have required role for method",
					zap.String("method", info.FullMethod),
					zap.String("user_id", claims.UserID),
					zap.String("user_role", claims.Role),
					zap.Strings("required_roles", roles))
				return nil, status.Errorf(codes.PermissionDenied, "user does not have required role: %s", claims.Role)
			}
			log.Debug("AuthInterceptor: user role authorized for method", zap.String("method", info.FullMethod), zap.String("user_role", claims.Role))
		}

		// 6. Add UserID and Role to context for handlers
		newCtx := context.WithValue(ctx, UserIDKey, claims.UserID)
		newCtx = context.WithValue(newCtx, UserRoleKey, claims.Role) // Add role to context

		log.Info("AuthInterceptor: user successfully authenticated and authorized",
			zap.String("method", info.FullMethod),
			zap.String("user_id", claims.UserID),
			zap.String("role", claims.Role))

		return handler(newCtx, req)
	}
}
